# evgenСолана ДЕКС
Ящик Солана Документация Солана Статус сборки

Строительство
1. Установите rustc,cargo и rustfmt.
$ curl https://sh.rustup.rs -sSf | ш
$ источник  $HOME /.cargo/env
Компонент $ rustup добавить rustfmt
При сборке основной ветки убедитесь, что вы используете последнюю стабильную версию Rust, запустив:

$ ржавое обновление
При сборке конкретной ветки релиза вы должны проверить версию ржавчины ci/rust-version.shи, если необходимо, установить эту версию, выполнив:

$ rustup установить ВЕРСИЯ
Обратите внимание, что если это не последняя версия ржавчины на вашем компьютере, для использования правильной версии может потребоваться переопределение команд Cargo.

В системах Linux вам может потребоваться установить libssl-dev, pkg-config, zlib1g-dev и т. д. В Ubuntu:

$ sudo apt-получить обновление
$ sudo apt-get install libssl-dev libudev-dev pkg-config zlib1g-dev llvm clang make
На Mac M1 убедитесь, что вы настроили свой терминал и хоумбрю для использования Rosetta. Вы можете установить его с помощью:

$ softwareupdate --install-rosetta
2. Загрузите исходный код.
$ git клон https://github.com/PatchDevel/solana-dex.git
$ cd солана-dex
3. Построить.
$ грузовая сборка
Тестирование
Запустите набор тестов:

$ грузовой тест
Запуск локальной тестовой сети
Запустите свою собственную тестовую сеть локально, инструкции есть в онлайн-документах .

Доступ к удаленному кластеру разработки
devnet- стабильный публичный кластер для разработки, доступный через devnet.solana.com. Работает круглосуточно и без выходных. Подробнее об общедоступных кластерах
Бенчмаркинг
Сначала установите ночную сборку rustc. cargo benchтребует использования нестабильных функций, доступных только в ночной сборке.

$ установка rustup каждую ночь
Запустите тесты:

$ груз+ночная скамейка
Процесс выпуска
Процесс релиза для этого проекта описан здесь .

Покрытие кода
Чтобы сгенерировать статистику покрытия кода:

$ скрипты/coverage.sh
$ open target/cov/lcov-local/index.html
Почему покрытие? В то время как большинство рассматривает охват как показатель качества кода, мы рассматриваем его в первую очередь как показатель продуктивности разработчика. Когда разработчик вносит изменения в кодовую базу, предположительно это решение какой-то проблемы. Наш набор модульных тестов — это то, как мы кодируем набор проблем , которые решает кодовая база. Запуск набора тестов должен показать, что ваше изменение не нарушило чьи-либо решения. Добавление теста защищаетваше решение от будущих изменений. Скажем, вы не понимаете, почему существует строка кода, попробуйте удалить ее и запустить модульные тесты. Ближайший сбой теста должен сказать вам, какая проблема была решена этим кодом. Если ни один из тестов не прошел успешно, отправьте запрос на слияние, в котором спрашивается: «Какую проблему решает этот код?» С другой стороны, если тест не пройден, и вы можете придумать лучший способ решения той же проблемы, запрос на слияние с вашим решением, безусловно, будет приветствоваться! Точно так же, если переписывание теста может лучше сообщить, какой код он защищает, отправьте нам этот патч!
